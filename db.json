{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/fabric/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/fabric/source/css/fabric.sass","path":"css/fabric.sass","modified":0,"renderable":1},{"_id":"themes/fabric/source/css/q.log","path":"css/q.log","modified":0,"renderable":1},{"_id":"themes/fabric/source/css/typo.css","path":"css/typo.css","modified":0,"renderable":1},{"_id":"themes/fabric/source/js/fabric.js","path":"js/fabric.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"63a8287317c6179ab991a175988b3895d2403f58","modified":1493880210000},{"_id":"themes/fabric/_config.yml","hash":"73e367d9ba6cc512beed073f02be5c99575c53e3","modified":1493880171000},{"_id":"themes/fabric/package.json","hash":"682b273642973d6b9be3e02c704ae7e9d69f9282","modified":1493880171000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1493880215000},{"_id":"source/_posts/2016-10-21-Hello-World.md","hash":"ac53723a2af2bcdc04c2a65b6e81126223bb4cb1","modified":1493880171000},{"_id":"source/_posts/2017-05-04-Immutable小记.md","hash":"372380f6161522623732051462c2d948936df4a1","modified":1493880171000},{"_id":"themes/fabric/languages/default.yml","hash":"3e06a33b3f75168dc758204aeb2383f0496fae72","modified":1493880171000},{"_id":"themes/fabric/layout/archive.jade","hash":"bcf8e6976b35406b613ec9868838f813e379fcc8","modified":1493880171000},{"_id":"themes/fabric/layout/category.jade","hash":"b636a8787b1fa40aa5734ed5c092f7ec424216d5","modified":1493880171000},{"_id":"themes/fabric/layout/index.jade","hash":"67e9e7c91895cc85e71708a28a0dff7d82c9fcab","modified":1493880171000},{"_id":"themes/fabric/layout/page.jade","hash":"c52bddf8c2cc8d72621438be39e2d4fdf7ecd6e0","modified":1493880171000},{"_id":"themes/fabric/layout/post.jade","hash":"b89a2c0bfc79e2cb4caf7f7a84aef510f95d61d3","modified":1493880171000},{"_id":"themes/fabric/layout/tag.jade","hash":"28a4177bcc8c959dac98f270e1766a3ee7857e1c","modified":1493880171000},{"_id":"themes/fabric/source/favicon.ico","hash":"96b9a549337c2bec483c2879eeafa4d1f8748fed","modified":1493880171000},{"_id":"themes/fabric/layout/includes/pagination.jade","hash":"03f8ad446492d641270d080f6bf40f92dd4d6872","modified":1493880171000},{"_id":"themes/fabric/layout/includes/layout.jade","hash":"2c3a6bfe3a673f3536889b48b42aa3ed4fcac64f","modified":1493880171000},{"_id":"themes/fabric/layout/includes/recent-posts.jade","hash":"13ee829c6c9f3dc480adbecdaea729bf5777dcb8","modified":1493880171000},{"_id":"themes/fabric/source/css/fabric.sass","hash":"9be752dd1f711917e1340577cf60ab8a85c5bfad","modified":1493880171000},{"_id":"themes/fabric/source/css/q.log","hash":"9cfb94b0a57a5edaf3da9b39db26d9ed9ede5b54","modified":1493880171000},{"_id":"themes/fabric/source/css/typo.css","hash":"94cc518b72a0102690a040bdcff625ac214b0019","modified":1493880171000},{"_id":"themes/fabric/source/js/fabric.js","hash":"a6b25262a25ea3e66db76e166dfb60c7bc6388d5","modified":1493880171000},{"_id":"public/2017/05/04/Immutable小记/index.html","hash":"8559b228f3c864ff2016fdf187ade33adb1e2df8","modified":1493881416722},{"_id":"public/2016/10/21/Hello-World/index.html","hash":"275b6a25a36ee15adda1b9fffaa855e5a8c089d3","modified":1493881416722},{"_id":"public/archives/index.html","hash":"a1e311c314c0327262ae110803d4ac5928c99b92","modified":1493881416723},{"_id":"public/archives/2016/index.html","hash":"2d42022d505bf3f9a91b3f3d36e1663944d7a0df","modified":1493881416723},{"_id":"public/archives/2016/10/index.html","hash":"6bf47e46c6dbc9d4d12d2e9131197652d313d441","modified":1493881416723},{"_id":"public/archives/2017/index.html","hash":"282dccd77b4cb1ad06a9a2c1f37c833e8531983a","modified":1493881416723},{"_id":"public/archives/2017/05/index.html","hash":"1574cde774c450b8c0883fdb52fde171625f29cb","modified":1493881416723},{"_id":"public/index.html","hash":"84e929cc6377d7c88c5b41e6225cf74c223adc96","modified":1493881416723},{"_id":"public/favicon.ico","hash":"96b9a549337c2bec483c2879eeafa4d1f8748fed","modified":1493881416724},{"_id":"public/css/q.log","hash":"9cfb94b0a57a5edaf3da9b39db26d9ed9ede5b54","modified":1493881416724},{"_id":"public/js/fabric.js","hash":"a6b25262a25ea3e66db76e166dfb60c7bc6388d5","modified":1493881416782},{"_id":"public/css/fabric.css","hash":"4d362bc718366a4e534338eab220b4269ec151b0","modified":1493881416783},{"_id":"public/css/typo.css","hash":"ef6ee6c4a16f034b9430659af2b96bbee9bc8533","modified":1493881416783}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Hello World","date":"2016-10-21T04:59:31.000Z","_content":"\nHello World\n\n```js\nvar a = 1;\n\nfunction test() {\n    console.log('test');\n}\n\n```\n","source":"_posts/2016-10-21-Hello-World.md","raw":"---\ntitle: Hello World\ndate: 2016-10-21 12:59:31\ntags:\n---\n\nHello World\n\n```js\nvar a = 1;\n\nfunction test() {\n    console.log('test');\n}\n\n```\n","slug":"Hello-World","published":1,"updated":"2017-05-04T06:42:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2a2fa3s0000psplgdtw9fd6","content":"<p>Hello World</p>\n<pre><code class=\"js\">var a = 1;\n\nfunction test() {\n    console.log(&#39;test&#39;);\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>Hello World</p>\n<pre><code class=\"js\">var a = 1;\n\nfunction test() {\n    console.log(&#39;test&#39;);\n}\n</code></pre>"},{"title":"Immutable小记","date":"2017-05-04T02:22:46.000Z","_content":"\n## React\nReact.js使用了virtual dom，通过diff修改dom，实现高效的dom更新。\n但是有一个问题，当state更新时，如果数据没变，也会去做virtual dom的diff，这就埋下了性能隐患。\n\n### PureRenderMixin（React.PureComponent）\n上面的问题可以通过使用 [PureRenderMixin]（[React.PureComponent]）解决。\n```javascript\nimport PureRenderMixin from 'react-addons-pure-render-mixin';\nclass FooComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this);\n  }\n\n  render() {\n    return <div className={this.props.className}>foo</div>;\n  }\n}\n```\n该mixin实现了 [shouldComponentUpdate] 的细节进行优化。\n\n### PureRender的问题\n它只是“浅比较”对象，如果是复杂的对象结构，那就出现了问题。\n比如这样的结构：\n```json\n{\n\t\"state\": {\n\t\t“some”: {\n\t\t\t\"time\": 123456,\n\t\t\t\"thing\": \"gg fly\",\n\t\t}\n\t}\n}\n```\n\n如果直接修改对象上的属性\n```javascript\nconst some = this.state.some;\nsome.time = +new Date();\nthis.setState({ some });\n```\n则组件不会进行重新渲染\n\n由于直接修改some上的time属性的值，some任然指向同一个对象。\n进过PureRenderMixin的优化，不进行重新渲染，造成“卡死”的情况。\n\n针对上面这种情况：\n1. 使用forceUpdate()更新；\n2. 使用不可变对象。\n\n## Immutable\n### mutable修改：\n这里就是上面问题的关键，只是更改了对象上的属性，而没有更改引用。\n```javascript\nconst x = {\n\tname: 'old name'\n};\n// 这里 x, y 指向同一个对象\nconst y = x;\ny.name = 'new name';\nconsole.log(x.name); // 'new name'\nconsole.log(y.name); // 'new name'\nconsole.log(x === y); // true\n```\n\n如何Immutable地修改呢？\n\n### 深拷贝：\n```javascript\nconst x = {\n\tname: 'old name'\n};\n// x, y 不指向同一个对象\nconst y = JSON.parse(JSON.stringify(x));\ny.name = 'new name';\nconsole.log(x.name); // 'old name'\nconsole.log(y.name); // 'new name'\nconsole.log(x === y); // false\n```\n深拷贝效率特别低，所以强烈不推荐使用。\n\n### Object.assign拷贝\n按照修改路径，使用 [Object.assign] 拷贝对象，构造新对象。\n```javascript\nconst x = {\n\tname: 'old name'\n};\n// x, y 不指向同一个对象\nconst y = Object.assign({}, x);\ny.name = 'new name';\nconsole.log(x.name); // 'old name'\nconsole.log(y.name); // 'new name'\nconsole.log(x === y); // false\n```\n这样就简单解决了问题，而且效率也比较高。\n\n数组可以使用 [Array.prototype.slice] 进行拷贝。\n\n### Object.assign拷贝的麻烦\n如果对象再“深”一些：\n```json\n{\n\t\"state\": {\n\t\t“some”: {\n\t\t\t\"time\": {\n\t\t\t\t\"good\": 123456,\n\t\t\t\t\"bad\": 78910,\n\t\t\t},\n\t\t\t\"thing\": \"gg fly\",\n\t\t}\n\t}\n}\n```\n\n那我们可能要一遍遍浅拷贝对象进行复制：\n```javascript\nconst some = this.state.some;\nconst neoSome = Object.assign({}, some, {\n\t\"time\": Object.assign({}, some.time, {\n\t\t\"good\": +new Date()\n\t})\n});\nthis.setState({ some: neoSome });\n```\n\n为了简化操作 或 加强相关功能，我们可以使用不可变相关的库方便我们编写代码。\n\n### Immutable库\nFacebook出品的 [Immutable.js]，比较复杂、重，真.重型解药\n[Immutability Helpers]，提供了方便编写的语法糖\n[object-path-immutable]，简单、轻便。\n\n项目中我们使用的是 object-path-immutable 配合 [Array.prototype.slice] & [Object.assign]\n\n## object-path-immutable\n### 使用\n官方简单例子：\n```javascript\nvar obj = {\n  a: {\n    b: 'c',\n    c: ['d', 'f']\n  }\n};\n\n//set a deep property\nvar newObj = immutable.set(obj, 'a.b', 'f');\n//returns\n//var obj = {\n//  a: {\n//    b: 'f',\n//    c: ['d', 'f']\n//  }\n//}\n\n//obj !== newObj\n//obj.a !== newObj.a\n//obj.b !== newObj.b\n\n//However:\n//obj.c === newObj.c\n```\n\n链式操作：\n```javascript\n//Chaining mode. value() at the end of the chain is used to retrieve the resulting object\nvar newObj = immutable(obj).set('a.b', 'f').del('a.c.0').value();\n\nvar neoState = immutable(obj);\n// ⚠️ 注意\n// 链式操作步骤如果分开，要把操作返回的新状态“串起来”\n// 否则会断链\n\n// ❌ 这样就“断链“了\nneoState.set('a.b', 'f');\nneoState.del('a.c.0');\n\n// ✅ 下面是正确的 \nneoState = neoState.set('a.b', 'f');\nneoState = neoState.del('a.c.0');\n\nvar newObj = neoState.value();\n```\n\n其他API，可查看文档按情况使用。\n\n## 参考： \n* [facebook immutable.js 意义何在，使用场景？](https://www.zhihu.com/question/28016223/answer/50292748)\n* [PureRenderMixin]（[React.PureComponent]）& [shouldComponentUpdate]\n* [Immutable.js]\n* [Immutability Helpers]\n* [object-path-immutable]\n\n[shouldComponentUpdate]: https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate\n[PureRenderMixin]: https://link.zhihu.com/?target=http%3A//facebook.github.io/react/docs/pure-render-mixin.html\n [React.PureComponent]: https://facebook.github.io/react/docs/react-api.html#react.purecomponent\n[Object.assign]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n[Array.prototype.slice]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\n[object-path-immutable]: https://github.com/mariocasciaro/object-path-immutable\n[Immutability Helpers]: https://facebook.github.io/react/docs/update.html\n[Immutable.js]: http://facebook.github.io/immutable-js/\n","source":"_posts/2017-05-04-Immutable小记.md","raw":"---\ntitle: Immutable小记\ndate: 2017-05-04 10:22:46\ntags:\n---\n\n## React\nReact.js使用了virtual dom，通过diff修改dom，实现高效的dom更新。\n但是有一个问题，当state更新时，如果数据没变，也会去做virtual dom的diff，这就埋下了性能隐患。\n\n### PureRenderMixin（React.PureComponent）\n上面的问题可以通过使用 [PureRenderMixin]（[React.PureComponent]）解决。\n```javascript\nimport PureRenderMixin from 'react-addons-pure-render-mixin';\nclass FooComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this);\n  }\n\n  render() {\n    return <div className={this.props.className}>foo</div>;\n  }\n}\n```\n该mixin实现了 [shouldComponentUpdate] 的细节进行优化。\n\n### PureRender的问题\n它只是“浅比较”对象，如果是复杂的对象结构，那就出现了问题。\n比如这样的结构：\n```json\n{\n\t\"state\": {\n\t\t“some”: {\n\t\t\t\"time\": 123456,\n\t\t\t\"thing\": \"gg fly\",\n\t\t}\n\t}\n}\n```\n\n如果直接修改对象上的属性\n```javascript\nconst some = this.state.some;\nsome.time = +new Date();\nthis.setState({ some });\n```\n则组件不会进行重新渲染\n\n由于直接修改some上的time属性的值，some任然指向同一个对象。\n进过PureRenderMixin的优化，不进行重新渲染，造成“卡死”的情况。\n\n针对上面这种情况：\n1. 使用forceUpdate()更新；\n2. 使用不可变对象。\n\n## Immutable\n### mutable修改：\n这里就是上面问题的关键，只是更改了对象上的属性，而没有更改引用。\n```javascript\nconst x = {\n\tname: 'old name'\n};\n// 这里 x, y 指向同一个对象\nconst y = x;\ny.name = 'new name';\nconsole.log(x.name); // 'new name'\nconsole.log(y.name); // 'new name'\nconsole.log(x === y); // true\n```\n\n如何Immutable地修改呢？\n\n### 深拷贝：\n```javascript\nconst x = {\n\tname: 'old name'\n};\n// x, y 不指向同一个对象\nconst y = JSON.parse(JSON.stringify(x));\ny.name = 'new name';\nconsole.log(x.name); // 'old name'\nconsole.log(y.name); // 'new name'\nconsole.log(x === y); // false\n```\n深拷贝效率特别低，所以强烈不推荐使用。\n\n### Object.assign拷贝\n按照修改路径，使用 [Object.assign] 拷贝对象，构造新对象。\n```javascript\nconst x = {\n\tname: 'old name'\n};\n// x, y 不指向同一个对象\nconst y = Object.assign({}, x);\ny.name = 'new name';\nconsole.log(x.name); // 'old name'\nconsole.log(y.name); // 'new name'\nconsole.log(x === y); // false\n```\n这样就简单解决了问题，而且效率也比较高。\n\n数组可以使用 [Array.prototype.slice] 进行拷贝。\n\n### Object.assign拷贝的麻烦\n如果对象再“深”一些：\n```json\n{\n\t\"state\": {\n\t\t“some”: {\n\t\t\t\"time\": {\n\t\t\t\t\"good\": 123456,\n\t\t\t\t\"bad\": 78910,\n\t\t\t},\n\t\t\t\"thing\": \"gg fly\",\n\t\t}\n\t}\n}\n```\n\n那我们可能要一遍遍浅拷贝对象进行复制：\n```javascript\nconst some = this.state.some;\nconst neoSome = Object.assign({}, some, {\n\t\"time\": Object.assign({}, some.time, {\n\t\t\"good\": +new Date()\n\t})\n});\nthis.setState({ some: neoSome });\n```\n\n为了简化操作 或 加强相关功能，我们可以使用不可变相关的库方便我们编写代码。\n\n### Immutable库\nFacebook出品的 [Immutable.js]，比较复杂、重，真.重型解药\n[Immutability Helpers]，提供了方便编写的语法糖\n[object-path-immutable]，简单、轻便。\n\n项目中我们使用的是 object-path-immutable 配合 [Array.prototype.slice] & [Object.assign]\n\n## object-path-immutable\n### 使用\n官方简单例子：\n```javascript\nvar obj = {\n  a: {\n    b: 'c',\n    c: ['d', 'f']\n  }\n};\n\n//set a deep property\nvar newObj = immutable.set(obj, 'a.b', 'f');\n//returns\n//var obj = {\n//  a: {\n//    b: 'f',\n//    c: ['d', 'f']\n//  }\n//}\n\n//obj !== newObj\n//obj.a !== newObj.a\n//obj.b !== newObj.b\n\n//However:\n//obj.c === newObj.c\n```\n\n链式操作：\n```javascript\n//Chaining mode. value() at the end of the chain is used to retrieve the resulting object\nvar newObj = immutable(obj).set('a.b', 'f').del('a.c.0').value();\n\nvar neoState = immutable(obj);\n// ⚠️ 注意\n// 链式操作步骤如果分开，要把操作返回的新状态“串起来”\n// 否则会断链\n\n// ❌ 这样就“断链“了\nneoState.set('a.b', 'f');\nneoState.del('a.c.0');\n\n// ✅ 下面是正确的 \nneoState = neoState.set('a.b', 'f');\nneoState = neoState.del('a.c.0');\n\nvar newObj = neoState.value();\n```\n\n其他API，可查看文档按情况使用。\n\n## 参考： \n* [facebook immutable.js 意义何在，使用场景？](https://www.zhihu.com/question/28016223/answer/50292748)\n* [PureRenderMixin]（[React.PureComponent]）& [shouldComponentUpdate]\n* [Immutable.js]\n* [Immutability Helpers]\n* [object-path-immutable]\n\n[shouldComponentUpdate]: https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate\n[PureRenderMixin]: https://link.zhihu.com/?target=http%3A//facebook.github.io/react/docs/pure-render-mixin.html\n [React.PureComponent]: https://facebook.github.io/react/docs/react-api.html#react.purecomponent\n[Object.assign]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n[Array.prototype.slice]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\n[object-path-immutable]: https://github.com/mariocasciaro/object-path-immutable\n[Immutability Helpers]: https://facebook.github.io/react/docs/update.html\n[Immutable.js]: http://facebook.github.io/immutable-js/\n","slug":"Immutable小记","published":1,"updated":"2017-05-04T06:42:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2a2fa3x0001pspligy3udqw","content":"<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><p>React.js使用了virtual dom，通过diff修改dom，实现高效的dom更新。<br>但是有一个问题，当state更新时，如果数据没变，也会去做virtual dom的diff，这就埋下了性能隐患。</p>\n<h3 id=\"PureRenderMixin（React-PureComponent）\"><a href=\"#PureRenderMixin（React-PureComponent）\" class=\"headerlink\" title=\"PureRenderMixin（React.PureComponent）\"></a>PureRenderMixin（React.PureComponent）</h3><p>上面的问题可以通过使用 <a href=\"https://link.zhihu.com/?target=http%3A//facebook.github.io/react/docs/pure-render-mixin.html\" target=\"_blank\" rel=\"external\">PureRenderMixin</a>（<a href=\"https://facebook.github.io/react/docs/react-api.html#react.purecomponent\" target=\"_blank\" rel=\"external\">React.PureComponent</a>）解决。</p>\n<pre><code class=\"javascript\">import PureRenderMixin from &#39;react-addons-pure-render-mixin&#39;;\nclass FooComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this);\n  }\n\n  render() {\n    return &lt;div className={this.props.className}&gt;foo&lt;/div&gt;;\n  }\n}\n</code></pre>\n<p>该mixin实现了 <a href=\"https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate\" target=\"_blank\" rel=\"external\">shouldComponentUpdate</a> 的细节进行优化。</p>\n<h3 id=\"PureRender的问题\"><a href=\"#PureRender的问题\" class=\"headerlink\" title=\"PureRender的问题\"></a>PureRender的问题</h3><p>它只是“浅比较”对象，如果是复杂的对象结构，那就出现了问题。<br>比如这样的结构：</p>\n<pre><code class=\"json\">{\n    &quot;state&quot;: {\n        “some”: {\n            &quot;time&quot;: 123456,\n            &quot;thing&quot;: &quot;gg fly&quot;,\n        }\n    }\n}\n</code></pre>\n<p>如果直接修改对象上的属性</p>\n<pre><code class=\"javascript\">const some = this.state.some;\nsome.time = +new Date();\nthis.setState({ some });\n</code></pre>\n<p>则组件不会进行重新渲染</p>\n<p>由于直接修改some上的time属性的值，some任然指向同一个对象。<br>进过PureRenderMixin的优化，不进行重新渲染，造成“卡死”的情况。</p>\n<p>针对上面这种情况：</p>\n<ol>\n<li>使用forceUpdate()更新；</li>\n<li>使用不可变对象。</li>\n</ol>\n<h2 id=\"Immutable\"><a href=\"#Immutable\" class=\"headerlink\" title=\"Immutable\"></a>Immutable</h2><h3 id=\"mutable修改：\"><a href=\"#mutable修改：\" class=\"headerlink\" title=\"mutable修改：\"></a>mutable修改：</h3><p>这里就是上面问题的关键，只是更改了对象上的属性，而没有更改引用。</p>\n<pre><code class=\"javascript\">const x = {\n    name: &#39;old name&#39;\n};\n// 这里 x, y 指向同一个对象\nconst y = x;\ny.name = &#39;new name&#39;;\nconsole.log(x.name); // &#39;new name&#39;\nconsole.log(y.name); // &#39;new name&#39;\nconsole.log(x === y); // true\n</code></pre>\n<p>如何Immutable地修改呢？</p>\n<h3 id=\"深拷贝：\"><a href=\"#深拷贝：\" class=\"headerlink\" title=\"深拷贝：\"></a>深拷贝：</h3><pre><code class=\"javascript\">const x = {\n    name: &#39;old name&#39;\n};\n// x, y 不指向同一个对象\nconst y = JSON.parse(JSON.stringify(x));\ny.name = &#39;new name&#39;;\nconsole.log(x.name); // &#39;old name&#39;\nconsole.log(y.name); // &#39;new name&#39;\nconsole.log(x === y); // false\n</code></pre>\n<p>深拷贝效率特别低，所以强烈不推荐使用。</p>\n<h3 id=\"Object-assign拷贝\"><a href=\"#Object-assign拷贝\" class=\"headerlink\" title=\"Object.assign拷贝\"></a>Object.assign拷贝</h3><p>按照修改路径，使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\" rel=\"external\">Object.assign</a> 拷贝对象，构造新对象。</p>\n<pre><code class=\"javascript\">const x = {\n    name: &#39;old name&#39;\n};\n// x, y 不指向同一个对象\nconst y = Object.assign({}, x);\ny.name = &#39;new name&#39;;\nconsole.log(x.name); // &#39;old name&#39;\nconsole.log(y.name); // &#39;new name&#39;\nconsole.log(x === y); // false\n</code></pre>\n<p>这样就简单解决了问题，而且效率也比较高。</p>\n<p>数组可以使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\" target=\"_blank\" rel=\"external\">Array.prototype.slice</a> 进行拷贝。</p>\n<h3 id=\"Object-assign拷贝的麻烦\"><a href=\"#Object-assign拷贝的麻烦\" class=\"headerlink\" title=\"Object.assign拷贝的麻烦\"></a>Object.assign拷贝的麻烦</h3><p>如果对象再“深”一些：</p>\n<pre><code class=\"json\">{\n    &quot;state&quot;: {\n        “some”: {\n            &quot;time&quot;: {\n                &quot;good&quot;: 123456,\n                &quot;bad&quot;: 78910,\n            },\n            &quot;thing&quot;: &quot;gg fly&quot;,\n        }\n    }\n}\n</code></pre>\n<p>那我们可能要一遍遍浅拷贝对象进行复制：</p>\n<pre><code class=\"javascript\">const some = this.state.some;\nconst neoSome = Object.assign({}, some, {\n    &quot;time&quot;: Object.assign({}, some.time, {\n        &quot;good&quot;: +new Date()\n    })\n});\nthis.setState({ some: neoSome });\n</code></pre>\n<p>为了简化操作 或 加强相关功能，我们可以使用不可变相关的库方便我们编写代码。</p>\n<h3 id=\"Immutable库\"><a href=\"#Immutable库\" class=\"headerlink\" title=\"Immutable库\"></a>Immutable库</h3><p>Facebook出品的 <a href=\"http://facebook.github.io/immutable-js/\" target=\"_blank\" rel=\"external\">Immutable.js</a>，比较复杂、重，真.重型解药<br><a href=\"https://facebook.github.io/react/docs/update.html\" target=\"_blank\" rel=\"external\">Immutability Helpers</a>，提供了方便编写的语法糖<br><a href=\"https://github.com/mariocasciaro/object-path-immutable\" target=\"_blank\" rel=\"external\">object-path-immutable</a>，简单、轻便。</p>\n<p>项目中我们使用的是 object-path-immutable 配合 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\" target=\"_blank\" rel=\"external\">Array.prototype.slice</a> &amp; <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\" rel=\"external\">Object.assign</a></p>\n<h2 id=\"object-path-immutable\"><a href=\"#object-path-immutable\" class=\"headerlink\" title=\"object-path-immutable\"></a>object-path-immutable</h2><h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>官方简单例子：</p>\n<pre><code class=\"javascript\">var obj = {\n  a: {\n    b: &#39;c&#39;,\n    c: [&#39;d&#39;, &#39;f&#39;]\n  }\n};\n\n//set a deep property\nvar newObj = immutable.set(obj, &#39;a.b&#39;, &#39;f&#39;);\n//returns\n//var obj = {\n//  a: {\n//    b: &#39;f&#39;,\n//    c: [&#39;d&#39;, &#39;f&#39;]\n//  }\n//}\n\n//obj !== newObj\n//obj.a !== newObj.a\n//obj.b !== newObj.b\n\n//However:\n//obj.c === newObj.c\n</code></pre>\n<p>链式操作：</p>\n<pre><code class=\"javascript\">//Chaining mode. value() at the end of the chain is used to retrieve the resulting object\nvar newObj = immutable(obj).set(&#39;a.b&#39;, &#39;f&#39;).del(&#39;a.c.0&#39;).value();\n\nvar neoState = immutable(obj);\n// ⚠️ 注意\n// 链式操作步骤如果分开，要把操作返回的新状态“串起来”\n// 否则会断链\n\n// ❌ 这样就“断链“了\nneoState.set(&#39;a.b&#39;, &#39;f&#39;);\nneoState.del(&#39;a.c.0&#39;);\n\n// ✅ 下面是正确的 \nneoState = neoState.set(&#39;a.b&#39;, &#39;f&#39;);\nneoState = neoState.del(&#39;a.c.0&#39;);\n\nvar newObj = neoState.value();\n</code></pre>\n<p>其他API，可查看文档按情况使用。</p>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><ul>\n<li><a href=\"https://www.zhihu.com/question/28016223/answer/50292748\" target=\"_blank\" rel=\"external\">facebook immutable.js 意义何在，使用场景？</a></li>\n<li><a href=\"https://link.zhihu.com/?target=http%3A//facebook.github.io/react/docs/pure-render-mixin.html\" target=\"_blank\" rel=\"external\">PureRenderMixin</a>（<a href=\"https://facebook.github.io/react/docs/react-api.html#react.purecomponent\" target=\"_blank\" rel=\"external\">React.PureComponent</a>）&amp; <a href=\"https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate\" target=\"_blank\" rel=\"external\">shouldComponentUpdate</a></li>\n<li><a href=\"http://facebook.github.io/immutable-js/\" target=\"_blank\" rel=\"external\">Immutable.js</a></li>\n<li><a href=\"https://facebook.github.io/react/docs/update.html\" target=\"_blank\" rel=\"external\">Immutability Helpers</a></li>\n<li><a href=\"https://github.com/mariocasciaro/object-path-immutable\" target=\"_blank\" rel=\"external\">object-path-immutable</a></li>\n</ul>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><p>React.js使用了virtual dom，通过diff修改dom，实现高效的dom更新。<br>但是有一个问题，当state更新时，如果数据没变，也会去做virtual dom的diff，这就埋下了性能隐患。</p>\n<h3 id=\"PureRenderMixin（React-PureComponent）\"><a href=\"#PureRenderMixin（React-PureComponent）\" class=\"headerlink\" title=\"PureRenderMixin（React.PureComponent）\"></a>PureRenderMixin（React.PureComponent）</h3><p>上面的问题可以通过使用 <a href=\"https://link.zhihu.com/?target=http%3A//facebook.github.io/react/docs/pure-render-mixin.html\" target=\"_blank\" rel=\"external\">PureRenderMixin</a>（<a href=\"https://facebook.github.io/react/docs/react-api.html#react.purecomponent\" target=\"_blank\" rel=\"external\">React.PureComponent</a>）解决。</p>\n<pre><code class=\"javascript\">import PureRenderMixin from &#39;react-addons-pure-render-mixin&#39;;\nclass FooComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this);\n  }\n\n  render() {\n    return &lt;div className={this.props.className}&gt;foo&lt;/div&gt;;\n  }\n}\n</code></pre>\n<p>该mixin实现了 <a href=\"https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate\" target=\"_blank\" rel=\"external\">shouldComponentUpdate</a> 的细节进行优化。</p>\n<h3 id=\"PureRender的问题\"><a href=\"#PureRender的问题\" class=\"headerlink\" title=\"PureRender的问题\"></a>PureRender的问题</h3><p>它只是“浅比较”对象，如果是复杂的对象结构，那就出现了问题。<br>比如这样的结构：</p>\n<pre><code class=\"json\">{\n    &quot;state&quot;: {\n        “some”: {\n            &quot;time&quot;: 123456,\n            &quot;thing&quot;: &quot;gg fly&quot;,\n        }\n    }\n}\n</code></pre>\n<p>如果直接修改对象上的属性</p>\n<pre><code class=\"javascript\">const some = this.state.some;\nsome.time = +new Date();\nthis.setState({ some });\n</code></pre>\n<p>则组件不会进行重新渲染</p>\n<p>由于直接修改some上的time属性的值，some任然指向同一个对象。<br>进过PureRenderMixin的优化，不进行重新渲染，造成“卡死”的情况。</p>\n<p>针对上面这种情况：</p>\n<ol>\n<li>使用forceUpdate()更新；</li>\n<li>使用不可变对象。</li>\n</ol>\n<h2 id=\"Immutable\"><a href=\"#Immutable\" class=\"headerlink\" title=\"Immutable\"></a>Immutable</h2><h3 id=\"mutable修改：\"><a href=\"#mutable修改：\" class=\"headerlink\" title=\"mutable修改：\"></a>mutable修改：</h3><p>这里就是上面问题的关键，只是更改了对象上的属性，而没有更改引用。</p>\n<pre><code class=\"javascript\">const x = {\n    name: &#39;old name&#39;\n};\n// 这里 x, y 指向同一个对象\nconst y = x;\ny.name = &#39;new name&#39;;\nconsole.log(x.name); // &#39;new name&#39;\nconsole.log(y.name); // &#39;new name&#39;\nconsole.log(x === y); // true\n</code></pre>\n<p>如何Immutable地修改呢？</p>\n<h3 id=\"深拷贝：\"><a href=\"#深拷贝：\" class=\"headerlink\" title=\"深拷贝：\"></a>深拷贝：</h3><pre><code class=\"javascript\">const x = {\n    name: &#39;old name&#39;\n};\n// x, y 不指向同一个对象\nconst y = JSON.parse(JSON.stringify(x));\ny.name = &#39;new name&#39;;\nconsole.log(x.name); // &#39;old name&#39;\nconsole.log(y.name); // &#39;new name&#39;\nconsole.log(x === y); // false\n</code></pre>\n<p>深拷贝效率特别低，所以强烈不推荐使用。</p>\n<h3 id=\"Object-assign拷贝\"><a href=\"#Object-assign拷贝\" class=\"headerlink\" title=\"Object.assign拷贝\"></a>Object.assign拷贝</h3><p>按照修改路径，使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\" rel=\"external\">Object.assign</a> 拷贝对象，构造新对象。</p>\n<pre><code class=\"javascript\">const x = {\n    name: &#39;old name&#39;\n};\n// x, y 不指向同一个对象\nconst y = Object.assign({}, x);\ny.name = &#39;new name&#39;;\nconsole.log(x.name); // &#39;old name&#39;\nconsole.log(y.name); // &#39;new name&#39;\nconsole.log(x === y); // false\n</code></pre>\n<p>这样就简单解决了问题，而且效率也比较高。</p>\n<p>数组可以使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\" target=\"_blank\" rel=\"external\">Array.prototype.slice</a> 进行拷贝。</p>\n<h3 id=\"Object-assign拷贝的麻烦\"><a href=\"#Object-assign拷贝的麻烦\" class=\"headerlink\" title=\"Object.assign拷贝的麻烦\"></a>Object.assign拷贝的麻烦</h3><p>如果对象再“深”一些：</p>\n<pre><code class=\"json\">{\n    &quot;state&quot;: {\n        “some”: {\n            &quot;time&quot;: {\n                &quot;good&quot;: 123456,\n                &quot;bad&quot;: 78910,\n            },\n            &quot;thing&quot;: &quot;gg fly&quot;,\n        }\n    }\n}\n</code></pre>\n<p>那我们可能要一遍遍浅拷贝对象进行复制：</p>\n<pre><code class=\"javascript\">const some = this.state.some;\nconst neoSome = Object.assign({}, some, {\n    &quot;time&quot;: Object.assign({}, some.time, {\n        &quot;good&quot;: +new Date()\n    })\n});\nthis.setState({ some: neoSome });\n</code></pre>\n<p>为了简化操作 或 加强相关功能，我们可以使用不可变相关的库方便我们编写代码。</p>\n<h3 id=\"Immutable库\"><a href=\"#Immutable库\" class=\"headerlink\" title=\"Immutable库\"></a>Immutable库</h3><p>Facebook出品的 <a href=\"http://facebook.github.io/immutable-js/\" target=\"_blank\" rel=\"external\">Immutable.js</a>，比较复杂、重，真.重型解药<br><a href=\"https://facebook.github.io/react/docs/update.html\" target=\"_blank\" rel=\"external\">Immutability Helpers</a>，提供了方便编写的语法糖<br><a href=\"https://github.com/mariocasciaro/object-path-immutable\" target=\"_blank\" rel=\"external\">object-path-immutable</a>，简单、轻便。</p>\n<p>项目中我们使用的是 object-path-immutable 配合 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\" target=\"_blank\" rel=\"external\">Array.prototype.slice</a> &amp; <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\" rel=\"external\">Object.assign</a></p>\n<h2 id=\"object-path-immutable\"><a href=\"#object-path-immutable\" class=\"headerlink\" title=\"object-path-immutable\"></a>object-path-immutable</h2><h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>官方简单例子：</p>\n<pre><code class=\"javascript\">var obj = {\n  a: {\n    b: &#39;c&#39;,\n    c: [&#39;d&#39;, &#39;f&#39;]\n  }\n};\n\n//set a deep property\nvar newObj = immutable.set(obj, &#39;a.b&#39;, &#39;f&#39;);\n//returns\n//var obj = {\n//  a: {\n//    b: &#39;f&#39;,\n//    c: [&#39;d&#39;, &#39;f&#39;]\n//  }\n//}\n\n//obj !== newObj\n//obj.a !== newObj.a\n//obj.b !== newObj.b\n\n//However:\n//obj.c === newObj.c\n</code></pre>\n<p>链式操作：</p>\n<pre><code class=\"javascript\">//Chaining mode. value() at the end of the chain is used to retrieve the resulting object\nvar newObj = immutable(obj).set(&#39;a.b&#39;, &#39;f&#39;).del(&#39;a.c.0&#39;).value();\n\nvar neoState = immutable(obj);\n// ⚠️ 注意\n// 链式操作步骤如果分开，要把操作返回的新状态“串起来”\n// 否则会断链\n\n// ❌ 这样就“断链“了\nneoState.set(&#39;a.b&#39;, &#39;f&#39;);\nneoState.del(&#39;a.c.0&#39;);\n\n// ✅ 下面是正确的 \nneoState = neoState.set(&#39;a.b&#39;, &#39;f&#39;);\nneoState = neoState.del(&#39;a.c.0&#39;);\n\nvar newObj = neoState.value();\n</code></pre>\n<p>其他API，可查看文档按情况使用。</p>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><ul>\n<li><a href=\"https://www.zhihu.com/question/28016223/answer/50292748\" target=\"_blank\" rel=\"external\">facebook immutable.js 意义何在，使用场景？</a></li>\n<li><a href=\"https://link.zhihu.com/?target=http%3A//facebook.github.io/react/docs/pure-render-mixin.html\" target=\"_blank\" rel=\"external\">PureRenderMixin</a>（<a href=\"https://facebook.github.io/react/docs/react-api.html#react.purecomponent\" target=\"_blank\" rel=\"external\">React.PureComponent</a>）&amp; <a href=\"https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate\" target=\"_blank\" rel=\"external\">shouldComponentUpdate</a></li>\n<li><a href=\"http://facebook.github.io/immutable-js/\" target=\"_blank\" rel=\"external\">Immutable.js</a></li>\n<li><a href=\"https://facebook.github.io/react/docs/update.html\" target=\"_blank\" rel=\"external\">Immutability Helpers</a></li>\n<li><a href=\"https://github.com/mariocasciaro/object-path-immutable\" target=\"_blank\" rel=\"external\">object-path-immutable</a></li>\n</ul>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}